# Мотивация

## Боль сейчас
- Заказы «теряются» в процессе обработки.
- Статусы застревают в разных системах: **Internet Shop**, **CRM**, **MES**.
- Партнёры не получают результаты через API.
- Отсутствует **сквозная видимость** — невозможно понять, где именно рвётся цепочка обработки заказа.

## Трейсинг даст
- Единый «кинопроектор» прохождения каждого заказа через все HTTP-запросы и сообщения в очередях.
- Быстрое выявление узких мест: API, БД, очереди, кэш.
- Точная диагностика причин: таймауты, ретраи, конфликты захвата, сбои публикации событий и т.п.

## Ожидаемый эффект
- Снижение **MTTR** (Mean Time to Resolve).
- Меньше просроченных заказов.
- Предсказуемые релизы.
- Понятные и измеримые **SLA** для B2C и B2B.

---

# Что покрываем трейсингом и где может «сломаться» / зависнуть

> **Нумерация соответствует блокам на C4-схеме.**

### 1. Internet Shop (Frontend)
**Покрытие:**
- Создание заказа
- Загрузка 3D-файла
- SUBMIT

**Риски:**
- Клиент получил ошибку/таймаут, но сервер принял заказ
- Загрузка файла оборвалась
- `trace` не передан дальше в бэкенд

---

### 2. Shop API (Spring Boot)
**Покрытие:**
- `POST /orders` (создание заказа)
- Загрузка файла
- Запись в **Shop DB**
- Формирование `outbox`-события `OrderSubmitted`
- Публикация в **RabbitMQ**

**Риски:**
- Транзакция в БД успешна, но событие не опубликовано (или наоборот)
- Долгие запросы / блокировки
- Дублирование заказов

---

### 3. CRM API (Spring Boot)
**Покрытие:**
- Потребление события `OrderSubmitted`
- Создание заказа в CRM
- Установка статусов: `MANUFACTURING_APPROVED`
- Публикация статусов

**Риски:**
- Consumer «залип» (не подтвердил сообщение)
- Нет идемпотентности → дубликаты
- Ошибки БД
- Невозможность подтвердить производство

---

### 4. MES API (C#)
**Покрытие:**
- Расчёт цены
- Присвоение операторов
- Статусы: `MANUFACTURING_STARTED`, `MANUFACTURING_COMPLETED`, `PACKAGING`, `SHIPPED`
- Публикация событий

**Риски:**
- Тяжёлый расчёт → таймауты / ретраи
- Гонки при «захвате» заказа
- Ошибки публикации или подтверждения

---

### 5. MES (Frontend)
**Покрытие:**
- Загрузка дашборда
- Операция «взять в работу»

**Риски:**
- Долгая загрузка списка «новых заказов»
- Конкуренция за заказы между операторами

---

### 6. RabbitMQ (Message Queue)
**Покрытие:**
- `publish` / `confirm`
- Routing
- `consume` / `ack`
- DLQ (Dead Letter Queue)
- Retries

**Риски:**
- Сообщение застряло в состоянии `unacked`
- Сообщение ушло в DLQ
- Лавинообразные ретраи

---

### 7. 3D Files Storage (S3-совместимое)
**Покрытие:**
- Выдача `presigned URL`
- Загрузка / чтение файла
- Постобработка / сканирование (если есть)

**Риски:**
- Файл недоступен для расчёта / производства
- Несоответствие версии

---

### 8. Shop DB / MES DB (PostgreSQL)
**Покрытие:**
- Ключевые транзакции по смене статуса
- Изоляция `outbox`-записи

**Риски:**
- Блокировки
- Долгие транзакции
- Конфликты версий при «claim»

---

### 9. Партнёрский вход (через MES API)
**Покрытие:**
- Приём заказа / расчёта
- Валидация
- Идемпотентность
- Постановка в очередь
- Ответ партнёру

**Риски:**
- Повторные запросы
- Превышение квот
- Не отправили ответ, но заказ принят

---

# Как связываем трассы

- **Пропагация контекста** через:
    - `traceparent` и `tracestate` (W3C стандарт)
    - Передача из **фронтенда** → **API** → **очередь** (в `message headers`) → **consumer** → последующие вызовы (HTTP/DB)
- Для **асинхронных событий** — `span links` между `publish` и `consume`.
- Для **outbox** — отдельные спаны:
    - `outbox_write`
    - `outbox_relay_publish`

---

# Данные, которые должны попадать в трейсинг

## Общие атрибуты спанов
- `trace_id`, `span_id`, `parent_id`
- `service.name`, `service.version`, `env`, `region/az`
- `http.method`, `http.route`, `http.status_code`
- `net.peer.ip` (обезличено), `user_agent` (усечённо)
- `messaging.system=rabbitmq`, `messaging.destination`, `messaging.operation=publish|receive|process`, `delivery_tag`, `message_id`, `retry_count`
- `db.system=postgresql`, `db.name`, `db.operation=select|insert|update|delete`, `row_count` (SQL-текст — только с маскированием)

## Доменные атрибуты
- `order_id`
- `previous_status`, `new_status`, `transition_name`
- `partner_id` (ограниченный справочник), `source=b2c|b2b`
- `idempotency_key`, `correlation_id`
- `claim_id` / `claimed_by` (роль/оператор, без персональных данных)
- `price_calc.input_hash` (хэш 3D-модели/параметров), `price_calc.complexity`, `result_price`
- `file_id`, `file_size_kb`, `storage_bucket`
- `outcome=success|retry|dead_letter|conflict`
- `error_code`, `exception.type`, `exception.message` (усечённо)

## События / логи в рамках спанов
- `publish_confirm_received`
- `ack_timeout`
- `redelivered=true`
- `moved_to_dlq`
- `redrive_started`, `redrive_finished`
- `cache_hit=true|false` (для рид-модели / калькуляции цены)
- `feature_flag_state` (для релизов)

---

# Семплирование

- **100%** — события смены статусов и ошибки.
- **20%** — прочие запросы.
- **Повышенное семплирование** — для партнёрских эндпойнтов.
- **Опционально** — `tail-based sampling` для выявления «медленных» трасс.

---

# Метрики, на которые повлияет внедрение трейсинга

## Технические
- **MTTR инцидентов**: ожидаем снижение в 2–4 раза за счёт точной локализации.
- **p95/p99 времени переходов** по цепочке:
    - `SUBMITTED → PRICE_CALCULATED`
    - `MANUFACTURING_APPROVED → MANUFACTURING_STARTED`
    - → появятся точные распределения и причины задержек.
- **Retry / DLQ rate** по очередям: трейс-метки покажут, кто и почему генерирует ретраи.
- **Доля запросов с кэш-хитом** для MES-дашборда и калькуляции цены.

## Бизнес-метрики
- **Доля заказов с нарушением SLA** по ключевым переходам:
    - Расчёт цены
    - Старт производства
    - Отгрузка
    - → топ-причины задержек.
- **Возраст старейшего заказа** в каждом статусе с привязкой к точке застревания (consumer, БД, внешний сервис).
- **Успешность партнёрского API**:
    - Доля идемпотентных дублей
    - Доля ответов, возвращённых >N секунд

---

# Мини-план внедрения трейсинга

1. Подключить **OpenTelemetry SDK** во все API и воркеры.
2. Включить автоперехват:
    - HTTP-запросов
    - RabbitMQ
    - PostgreSQL
3. Принять стандарт атрибутов и имён спанов.
4. Добавить **доменные спаны** на:
    - Смены статусов
    - Операции «claim»
5. Обеспечить пропагацию контекста:
    - Через HTTP-заголовки
    - Через RabbitMQ headers
6. Внедрить `span links` для асинхронных событий.
7. Настроить хранение трасс в **Tempo** или **Jaeger** с указанным семплированием.
8. Связать трассы с логами по `trace_id`.
9. Создать дашборды в **Grafana**:
    - «Жизненный цикл заказа»
    - «RabbitMQ: publish → process»
    - «MES дашборд / claim»

---

# Раздел: Компромиссы

## Где трейсинг не поможет, дорог или пока невозможен

### Проприетарные / внешние системы
- **Транспортные компании, сторонние платёжные системы, внешние склады**:
    - Мы не контролируем их код → невозможно продолжить `tracecontext` за пределы своей системы.
    - **Компенсация**: корреляция по `correlation_id` в запросах и вебхуках, плюс метрики: таймауты, ошибки, статусы.

### Прямые загрузки в объектное хранилище (presigned URL)
- Клиент загружает файл напрямую в S3 без прохождения через бэкенд.
- **Проблема**: в трейсе видим только выдачу `presigned URL`, но не сам `upload`.
- **Решение**:
    - Слушаем события `object created` (S3 Event Notifications).
    - Фиксируем факт загрузки как «контрольное» событие с привязкой к `order_id` и `trace_id`.
    - Не полноценный спан, но позволяет закрыть логическую цепочку.

### Старые / нестандартные клиенты (AMQP / HTTP)
- Некоторые продюсеры/консьюмеры:
    - Не поддерживают заголовки (`headers`)
    - Отбрасывают `traceparent` из-за размера или политик
    - Используют легаси-адаптеры (например, самописные C#-клиенты для RabbitMQ)
- **Результат**: сквозной контекст теряется.
- **Компромисс**: частичное покрытие, ручная инструментация, либо метрики + логи по `correlation_id`.

### Узлы «внутри» тяжёлых библиотек / WASM
- Например: 3D-обработчики, сторонние SDK, встраиваемые модули.
- Автоинструментация OpenTelemetry **не видит** внутренние вызовы.
- **Доступно только**:
    - Охватывающий спан до и после вызова (`"3d_processing"`).
    - Ручное логирование ключевых этапов (если возможно).
- **Ограничение**: нет детализации по внутренним шагам.

### Высокая стоимость при 100% семплировании
- Полный сбор трасс на всех эндпойнтах:
    - Резко растёт объём данных (S3/GCS, индексация).
    - Увеличивается нагрузка на CPU/память (Collector, Agent).
    - Риск перегрузки сети и платформы.
- **Компромисс**:
    - **Head-based sampling**: 10–20% для обычных запросов.
    - **Tail-based sampling** (опционально): 100% для медленных (>10s) и ошибочных трасс.
    - Приоритет — критичные пути: смена статусов, партнёрские API.

### Кардинальность и приватность
- Хранение полных `payload`, PII (email, адрес, телефон), токенов — **запрещено**.
- **Последствия**:
    - Трейсы менее детализированы.
    - Иногда приходится переходить в приложенческие логи по `trace_id`.
- **Решение**:
    - Фильтрация на уровне OpenTelemetry Collector.
    - Использование `correlation_id`, `order_id` — безопасные идентификаторы.

### Фронтенд-трейсинг (RUM — Real User Monitoring)
- Блокируется:
    - Ad-block’ерами
    - CORS / No-Cookie политиками
    - Некоторыми браузерами (особенно в приватном режиме)
- **Результат**: часть клиентских сессий остаётся без трасс.
- **Компенсация**:
    - Серверные спаны (первый запрос в API уже содержит `traceparent`).
    - Синтетические проверки (health-checks с трейсингом).

---

## Операционные компромиссы

### Оверхед на сервисы
- Автоинструментация и отправка OTLP добавляют **3–10%** нагрузки на CPU и память.
- **Критично для**:
    - Высоконагруженных сервисов (MES API).
    - Легаси-сервисов с узкими ресурсными рамками.
- **Решение**:
    - Тонкая настройка семплирования.
    - Агрегация спанов в «пачки».
    - Отключение несущественных спанов (например, health-checks).

### Сложность внедрения в очередях
- Чтобы сохранить сквозной контекст, нужно **дисциплинированно**:
    - Прокидывать `traceparent` и `correlation_id` в `message headers`.
    - Подтверждать потребление (`ack`) только после обработки.
- **Риск**: частичная интеграция → «оборванные» трассы.
- **Мера**: стандартизация шаблонов консьюмеров, проверки в CI.

---

# Раздел: Безопасность

## Аутентификация и авторизация

- **SSO по OIDC/SAML** через корпоративный IdP (Keycloak, Okta).
- Доступ к **Grafana** и **Tempo** — только у сотрудников с активной учётной записью.

### Роли и права (RBAC)

| Роль | Доступ |
|------|--------|
| **Support / ReadOnly** | Просмотр дашбордов и трейсов, без экспорта |
| **Developer** | Просмотр, редактирование и сохранение дашбордов по своим сервисам |
| **SRE** | Полный read, настройка алертов, управление дашбордами |
| **Admin** | Администрирование платформы (Collector, Tempo, Grafana) |

### Разделение окружений
- Отдельные **организации/тенанты** (или инстансы) для:
    - `dev`
    - `release`
    - `prod`
- **Кросс-доступ запрещён**. Нет «просмотра продакшена» из dev.

---

## Сетевой периметр

- Все компоненты трейсинга — в **приватных подсетях VPC**.
- Нет прямого доступа к интернету.
- Доступ — только через **VPN** или **бастион-хост**.

### Security Groups
- OTLP-приёмники (Collector) принимают данные **только от CIDR-диапазонов** наших сервисов.
- **Grafana** и **Tempo** — за внутренним Load Balancer, **внешнего доступа нет**.

### Шифрование и безопасность транспорта
- **mTLS** между сервисами и OpenTelemetry Collector (Agent/Gateway).
- **TLS** от Gateway до Tempo (и до S3-бэкенда).
- S3-хранилище: **SSE-KMS**, ключи в KMS с регулярной ротацией.

### Rate Limiting и квоты
- На Collector настроены лимиты:
    - По объёму данных (MB/s)
    - По количеству спанов (spans/s)
- Предотвращает перегрузку от:
    - Ошибочно настроенных сервисов
    - Легаси-приложений с высокой частотой логирования

---

## Защита данных

### Маскирование и фильтрация на уровне Collector
- Автоматическое удаление:
    - PII: email, phone, адреса
    - Секреты: токены, пароли, ключи
    - Request/response body (если не маскированы на уровне приложения)
- Разрешены к передаче:
    - `order_id`, `partner_id`, `correlation_id` — только как атрибуты спанов и логов
    - **Не допускаются** в метках метрик (из-за кардинальности)

### Шифрование «на диске»
- **Tempo**: объектное хранилище с **SSE-KMS**.
- Ключи шифрования — в **KMS**, ротация по политике (90 дней).
- Нет доступа к «сырым» данным без аутентификации и авторизации.

### Ретеншн и соответствие
- **prod**: 30 дней
- **non-prod**: 7–14 дней
- Автоматическое удаление по TTL.
- **Экспорт трасс** — только по заявке, с:
    - Указанием причины
    - Одобрением от SRE/Security
    - Журналированием действия

---

## Журналирование и аудиты

- Ведение **аудит-логов** в Grafana и Tempo:
    - Кто, когда и что открыл/изменил/экспортировал.
- Интеграция с **SIEM/SOC**:
    - Алерт при:
        - Множественных неуспешных попытках входа
        - Аномальных скачках объёма экспорта
        - Доступе с подозрительных IP
- Все события хранятся в централизованной системе логов (например, ELK/Splunk).

---

## Операционные меры

- **Runbooks**:
    - «Утечка PII в трейсе» — немедленное отключение источника, санитизация данных, расследование.
- **Тесты соответствия**:
    - Регулярные e2e-проверки, что PII не попадает в трассы.
    - Регулярные сканирования коллекторов по регулярным выражениям (email, phone и т.п.).

---

## Границы доступа снаружи (если потребуется)

- **Внешним подрядчикам** — **прямой доступ запрещён**.
- При необходимости:
    - Экспорт **обезличенных трасс** по запросу.
    - Временная ссылка с:
        - Подписью
        - Сроком жизни (например, 24 часа)
        - Шифрованием
    - Только после **юридического согласования (NDA)**.

- **Публичных дашбордов** — нет.

---

# Итог

**Применяем трейсинг там, где он приносит максимальную пользу**:
- Границы взаимодействия: **HTTP ↔ DB ↔ AMQP ↔ Storage**
- Ключевые **доменные переходы статусов**
- Сложные **асинхронные цепочки** с outbox и retry

 **Управляем рисками и стоимостью**:
- Через **семплирование** (head/tail-based)
- **Санитизацию атрибутов** и фильтрацию PII
- **Приватные сети**, **mTLS**, **RBAC**
- **Ретеншн-политики** и **аудит**

 **Осознаём ограничения**:
- Внешние системы, прямые загрузки в S3, легаси-клиенты, часть браузеров — могут оставаться «слепыми зонами».
- **Компенсируем**:
    - Корреляцией по `correlation_id` и `trace_id`
    - Метриками и событиями (S3, webhook, DLQ)
    - Синтетическими проверками

 **Цель достигнута**: сквозная видимость, быстрая диагностика, доверие к SLA — при контролируемой нагрузке и в рамках политик безопасности.